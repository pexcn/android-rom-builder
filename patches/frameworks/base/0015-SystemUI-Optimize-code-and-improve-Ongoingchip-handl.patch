From d9ef418855fa2d2df624563c3ba97b4d4f606a5c Mon Sep 17 00:00:00 2001
From: Ghosuto <clash.raja10@gmail.com>
Date: Wed, 26 Mar 2025 07:58:27 +0000
Subject: [PATCH 15/24] SystemUI: Optimize code and improve Ongoingchip
 handling

Signed-off-by: Ghosuto <clash.raja10@gmail.com>
---
 .../layout/status_bar_ongoing_action_chip.xml |  12 +-
 .../OnGoingActionProgressController.java      | 482 +++++++-----------
 2 files changed, 201 insertions(+), 293 deletions(-)

diff --git a/packages/SystemUI/res/layout/status_bar_ongoing_action_chip.xml b/packages/SystemUI/res/layout/status_bar_ongoing_action_chip.xml
index 4a2c7958b..3b36b5678 100644
--- a/packages/SystemUI/res/layout/status_bar_ongoing_action_chip.xml
+++ b/packages/SystemUI/res/layout/status_bar_ongoing_action_chip.xml
@@ -32,13 +32,13 @@
     android:focusable="true" >
 
     <ImageView
-        android:id="@+id/ongoing_action_app_icon"
+	    android:id="@+id/ongoing_action_app_icon"
         android:layout_width="8sp"
-        android:layout_height="8sp"
-        android:contentDescription="App icon"
-        android:gravity="center_vertical|start"
+	    android:layout_height="8sp"
+	    android:gravity="center_vertical|start"
         android:scaleType="centerInside"
-        android:tint="?android:attr/colorForeground"
+        android:contentDescription="App icon"
+        android:tint="@android:color/transparent"
         android:src="@android:drawable/sym_def_app_icon" />
 
     <View
@@ -46,7 +46,7 @@
         android:layout_height="0dp" />
 
     <ProgressBar
-        android:id="@+id/app_action_progress"
+	    android:id="@+id/app_action_progress"
         style="?android:attr/progressBarStyleHorizontal"
         android:layout_width="wrap_content"
         android:layout_height="8sp"
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java b/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
index f0c67fcda..411bebd24 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
@@ -49,12 +49,11 @@ import com.android.systemui.statusbar.OnGoingActionProgressGroup;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.util.MediaSessionManagerHelper;
 
-/** Controls the ongoing progress chip based on notifcations @LineageExtension */
+/** Controls the ongoing progress chip based on notifications @LineageExtension */
 public class OnGoingActionProgressController implements NotificationListener.NotificationHandler, KeyguardStateController.Callback {
     private static final String TAG = "OngoingActionProgressController";
     private static final String ONGOING_ACTION_CHIP_ENABLED = "ongoing_action_chip";
     private static final String SHOW_MEDIA_PROGRESS = "show_media_progress";
-
     private static final int SWIPE_THRESHOLD = 100;
     private static final int SWIPE_VELOCITY_THRESHOLD = 100;
 
@@ -62,91 +61,42 @@ public class OnGoingActionProgressController implements NotificationListener.Not
     private ContentResolver mContentResolver;
     private final Handler mHandler;
     private final SettingsObserver mSettingsObserver;
+    private final KeyguardStateController mKeyguardStateController;
+    private final NotificationListener mNotificationListener;
+    private final IconFetcher mIconFetcher;
+    private final MediaSessionManagerHelper mMediaSessionHelper;
 
-    // Views of chip
     private final ProgressBar mProgressBar;
     private final View mProgressRootView;
     private final ImageView mIconView;
 
-    // Keyguard state
-    private final KeyguardStateController mKeyguardStateController;
-
-    // Progress tracking variables
     private boolean mShowMediaProgress = true;
     private boolean mIsTrackingProgress = false;
     private boolean mIsForceHidden = false;
+    private boolean mIsEnabled;
     private int mCurrentProgress = 0;
     private int mCurrentProgressMax = 0;
     private Drawable mCurrentDrawable = null;
     private String mTrackedNotificationKey;
-
-    private final IconFetcher mIconFetcher;
-    private final NotificationListener mNotificationListener;
-    private boolean mIsEnabled;
     private PopupWindow mMediaPopup;
 
     private final GestureDetector mGestureDetector;
-    private final MediaSessionManagerHelper mMediaSessionHelper;
-
-    // Handler for real-time media progress updates
     private final Handler mMediaProgressHandler = new Handler(Looper.getMainLooper());
     private final Runnable mMediaProgressRunnable = new Runnable() {
         @Override
         public void run() {
             if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
                 updateViews();
-                mMediaProgressHandler.postDelayed(this, 1000); // Update every second
+                mMediaProgressHandler.postDelayed(this, 1000);
             }
         }
     };
 
-    private static int getThemeColor(Context context, int attrResId) {
-        TypedValue typedValue = new TypedValue();
-        context.getTheme().resolveAttribute(attrResId, typedValue, true);
-        return typedValue.data;
-    }
-
-    private class SettingsObserver extends ContentObserver {
-        SettingsObserver(Handler handler) {
-            super(handler);
-        }
-
-        @Override
-        public void onChange(boolean selfChange, Uri uri) {
-            super.onChange(selfChange, uri);
-            if (uri.equals(Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED)) ||
-                uri.equals(Settings.System.getUriFor(SHOW_MEDIA_PROGRESS))) {
-                updateSettings();
-            }
-        }
-
-        public void register() {
-            mContentResolver.registerContentObserver(
-                Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED),
-                false, this, UserHandle.USER_ALL);
-            
-            // Register observer for media progress toggle
-            mContentResolver.registerContentObserver(
-                Settings.System.getUriFor(SHOW_MEDIA_PROGRESS),
-                false, this, UserHandle.USER_ALL);
-            
-            updateSettings();
-        }
-
-        public void unregister() {
-            mContentResolver.unregisterContentObserver(this);
-        }
-    }
-
-    /**
-     * Creates controller for ongoing progress notifications
-     *
-     * @param View status bar View object to find progress chip
-     */
+    /** Constructor */
     public OnGoingActionProgressController(
             Context context, OnGoingActionProgressGroup progressGroup,
             NotificationListener notificationListener,
-			KeyguardStateController keyguardStateController) {
+            KeyguardStateController keyguardStateController) {
         if (progressGroup == null) {
             Log.wtf(TAG, "progressGroup is null");
         }
@@ -154,145 +104,88 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         if (mNotificationListener == null) {
             Log.wtf(TAG, "mNotificationListener is null");
         }
+
         mKeyguardStateController = keyguardStateController;
         keyguardStateController.addCallback(this);
         mContext = context;
         mContentResolver = context.getContentResolver();
         mHandler = new Handler(Looper.getMainLooper());
         mSettingsObserver = new SettingsObserver(mHandler);
-        
+
         mProgressBar = progressGroup.progressBarView;
         mProgressRootView = progressGroup.rootView;
         mIconView = progressGroup.iconView;
+
         mIconFetcher = new IconFetcher(context);
         mNotificationListener.addNotificationHandler(this);
         mMediaSessionHelper = MediaSessionManagerHelper.Companion.getInstance(context);
-        
-        // ðŸ”¹ Initialize gesture detector for media progress bar actions
-        mGestureDetector = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {
-            @Override
-            public boolean onSingleTapConfirmed(MotionEvent e) {
-                if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
-                    showMediaPopup(mProgressRootView);
-                } else {
-                    openTrackedApp();
-                }
-                return true;
-            }
 
-            @Override
-            public boolean onDoubleTap(MotionEvent e) {
-                if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
-                    toggleMediaPlaybackState();
-                }
-                return true;
-            }
+        mGestureDetector = new GestureDetector(mContext, new MediaGestureListener());
 
+        mSettingsObserver.register();
+        mProgressRootView.setOnTouchListener((v, event) -> mGestureDetector.onTouchEvent(event));
+        mMediaSessionHelper.addMediaMetadataListener(new MediaSessionManagerHelper.MediaMetadataListener() {
             @Override
-            public void onLongPress(MotionEvent e) {
-                if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
-                    openMediaApp();
-                }
+            public void onMediaMetadataChanged() {
+                updateViews();
             }
 
             @Override
-            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-                if (!(mShowMediaProgress && mMediaSessionHelper.isMediaPlaying())) {
-                    return false;
-                }
-
-                float diffX = e2.getX() - e1.getX();
-                if (Math.abs(diffX) > Math.abs(e2.getY() - e1.getY())) {
-                    if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {
-                        if (diffX > 0) {
-                            skipToNextTrack();
-                        } else {
-                            skipToPreviousTrack();
-                        }
-                        return true;
-                    }
-                }
-                return false;
+            public void onPlaybackStateChanged() {
+                updateViews();
             }
-
         });
 
-        // Register settings observer
-        mSettingsObserver.register();
-        mProgressRootView.setOnTouchListener((v, event) -> mGestureDetector.onTouchEvent(event));
-        // Add Media Listener to Update UI on Media Playback Change
-            mMediaSessionHelper.addMediaMetadataListener(new MediaSessionManagerHelper.MediaMetadataListener() {
-                @Override
-                public void onMediaMetadataChanged() {
-                    updateViews();
-                }
-
-                @Override
-                public void onPlaybackStateChanged() {
-                    updateViews();
-                }
-            });
-        }
-
-    /** Checks whether notification has progress */
-    private static boolean hasProgress(final Notification notification) {
-        Bundle extras = notification.extras;
-        boolean indeterminate =
-                notification.extras.getBoolean(Notification.EXTRA_PROGRESS_INDETERMINATE, false);
-
-        boolean maxProgressValid =
-                notification.extras.getInt(Notification.EXTRA_PROGRESS_MAX, 0) > 0;
-
-        return extras.containsKey(Notification.EXTRA_PROGRESS)
-                && extras.containsKey(Notification.EXTRA_PROGRESS_MAX)
-                && !indeterminate
-                && maxProgressValid;
-    }
-
-    /** Starts tracking progress of certain notification @AsyncUnsafe */
-    private void trackProgress(final StatusBarNotification sbn) {
-        // Here we set progress tracking and update view if needed
-        mIsTrackingProgress = true;
-        mTrackedNotificationKey = sbn.getKey();
-        Notification notification = sbn.getNotification();
-        mCurrentProgressMax = notification.extras.getInt(Notification.EXTRA_PROGRESS_MAX, 100);
-        mCurrentProgress = notification.extras.getInt(Notification.EXTRA_PROGRESS, 0);
-        IconFetcher.AdaptiveDrawableResult drawable =
-                mIconFetcher.getMonotonicPackageIcon(sbn.getPackageName());
-        mCurrentDrawable = drawable.drawable;
-        updateIconImageView(drawable);
         updateViews();
     }
 
-    /** Updates icon based on result from IconFetcher @AsyncUnsafe */
-    private void updateIconImageView(IconFetcher.AdaptiveDrawableResult drawable) {
-        if (drawable.isAdaptive) {
-            mIconView.setImageTintList(
-                    ColorStateList.valueOf(
-                            getThemeColor(mContext, android.R.attr.colorForeground)));
-        } else {
-            mIconView.setImageTintList(null);
+    /** Gesture listener for media controls */
+    private class MediaGestureListener extends GestureDetector.SimpleOnGestureListener {
+        @Override
+        public boolean onSingleTapConfirmed(MotionEvent e) {
+            if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
+                showMediaPopup(mProgressRootView);
+            } else {
+                openTrackedApp();
+            }
+            return true;
         }
-        mIconView.setImageDrawable(drawable.drawable);
-    }
 
-    /** Updates progress if needed @AsyncUnsafe */
-    private void updateProgressIfNeeded(final StatusBarNotification sbn) {
-        if (!mIsTrackingProgress) {
-            Log.wtf(TAG, "Called updateProgress if needed, but we do not tracking anything");
-            return;
+        @Override
+        public boolean onDoubleTap(MotionEvent e) {
+            if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
+                toggleMediaPlaybackState();
+            }
+            return true;
         }
-        // Log.d(TAG, "updateProgressIfNeeded: got notification update");
-        Notification notification = sbn.getNotification();
-        if (sbn.getKey().equals(mTrackedNotificationKey)) {
-            mCurrentProgressMax = notification.extras.getInt(Notification.EXTRA_PROGRESS_MAX, 100);
-            mCurrentProgress = notification.extras.getInt(Notification.EXTRA_PROGRESS, 0);
-            Log.d(TAG, "updateProgressIfNeeded: about to updateViews()");
-            updateViews();
+
+        @Override
+        public void onLongPress(MotionEvent e) {
+            if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
+                openMediaApp();
+            }
+        }
+
+        @Override
+        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+            if (!(mShowMediaProgress && mMediaSessionHelper.isMediaPlaying())) {
+                return false;
+            }
+            float diffX = e2.getX() - e1.getX();
+            if (Math.abs(diffX) > Math.abs(e2.getY() - e1.getY()) &&
+                    Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {
+                if (diffX > 0) {
+                    skipToNextTrack();
+                } else {
+                    skipToPreviousTrack();
+                }
+                return true;
+            }
+            return false;
         }
     }
 
-    /** Updates progress views @AsyncUnsafe */
+    /** Updates the UI based on current state */
     private void updateViews() {
         if (mIsForceHidden) {
             mProgressRootView.setVisibility(View.GONE);
@@ -300,52 +193,45 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         }
 
         boolean isMediaPlaying = mShowMediaProgress && mMediaSessionHelper.isMediaPlaying();
-
-        // If media is playing and it's enabled, show media progress
         if (isMediaPlaying) {
-            mProgressRootView.setVisibility(View.VISIBLE);
-
-            mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
-            mMediaProgressHandler.post(mMediaProgressRunnable);
-
-            // Get media app icon and update it
-            Drawable mediaAppIcon = mMediaSessionHelper.getMediaAppIcon();
-            if (mediaAppIcon != null) {
-                mIconView.setImageDrawable(mediaAppIcon);
-            } else {
-                mIconView.setImageResource(R.drawable.ic_default_music_icon);
-            }
-
-            long totalDuration = mMediaSessionHelper.getTotalDuration();
-            long currentProgress = mMediaSessionHelper.getMediaControllerPlaybackState() != null
-                    ? mMediaSessionHelper.getMediaControllerPlaybackState().getPosition()
-                    : 0;
+            updateMediaProgress();
+        } else {
+            updateNotificationProgress();
+        }
+    }
 
-            if (totalDuration > 0) {
-                mProgressBar.setMax((int) totalDuration);
-                mProgressBar.setProgress((int) currentProgress);
-            }
+    /** Updates UI for media playback progress */
+    private void updateMediaProgress() {
+        mProgressRootView.setVisibility(View.VISIBLE);
+        mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
+        mMediaProgressHandler.post(mMediaProgressRunnable);
 
-            // Attach Swipe Gesture for Media Progress Bar
-            mProgressRootView.setOnTouchListener((v, event) -> mGestureDetector.onTouchEvent(event));
+        Drawable mediaAppIcon = mMediaSessionHelper.getMediaAppIcon();
+        mIconView.setImageDrawable(mediaAppIcon != null ? mediaAppIcon : mContext.getResources().getDrawable(R.drawable.ic_default_music_icon));
 
-            return;
+        long totalDuration = mMediaSessionHelper.getTotalDuration();
+        long currentProgress = mMediaSessionHelper.getMediaControllerPlaybackState() != null
+                ? mMediaSessionHelper.getMediaControllerPlaybackState().getPosition() : 0;
+        if (totalDuration > 0) {
+            mProgressBar.setMax((int) totalDuration);
+            mProgressBar.setProgress((int) currentProgress);
         }
 
-        // If no media is playing, show download/upload progress as usual
+        mProgressRootView.setOnTouchListener((v, event) -> mGestureDetector.onTouchEvent(event));
+    }
+
+    /** Updates UI for notification progress */
+    private void updateNotificationProgress() {
         if (!mIsEnabled || !mIsTrackingProgress) {
             mProgressRootView.setVisibility(View.GONE);
             mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
-
-            // ðŸ”¹ Reset media icon when media stops playing
             if (!mMediaSessionHelper.isMediaPlaying()) {
-                mIconView.setImageDrawable(null); 
+                mIconView.setImageDrawable(null);
             }
             return;
         }
 
         mProgressRootView.setVisibility(View.VISIBLE);
-
         if (mCurrentProgressMax <= 0) {
             Log.w(TAG, "updateViews: invalid max progress " + mCurrentProgressMax + ", using 100");
             mCurrentProgressMax = 100;
@@ -355,15 +241,8 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         mProgressBar.setMax(mCurrentProgressMax);
         mProgressBar.setProgress(mCurrentProgress);
 
-        // When switching to download progress, update the correct download app icon
         if (mTrackedNotificationKey != null) {
-            StatusBarNotification sbn = null;
-            for (StatusBarNotification notification : mNotificationListener.getActiveNotifications()) {
-                if (notification.getKey().equals(mTrackedNotificationKey)) {
-                    sbn = notification;
-                    break;
-                }
-            }
+            StatusBarNotification sbn = findNotificationByKey(mTrackedNotificationKey);
             if (sbn != null) {
                 Drawable downloadAppIcon = mIconFetcher.getMonotonicPackageIcon(sbn.getPackageName()).drawable;
                 if (downloadAppIcon != null) {
@@ -373,36 +252,85 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         }
     }
 
+    /** Helper to extract progress from a notification */
+    private void extractProgress(Notification notification) {
+        mCurrentProgressMax = notification.extras.getInt(Notification.EXTRA_PROGRESS_MAX, 100);
+        mCurrentProgress = notification.extras.getInt(Notification.EXTRA_PROGRESS, 0);
+    }
+
+    /** Tracks progress of a notification */
+    private void trackProgress(final StatusBarNotification sbn) {
+        mIsTrackingProgress = true;
+        mTrackedNotificationKey = sbn.getKey();
+        extractProgress(sbn.getNotification());
+        IconFetcher.AdaptiveDrawableResult drawable = mIconFetcher.getMonotonicPackageIcon(sbn.getPackageName());
+        mCurrentDrawable = drawable.drawable;
+        updateIconImageView(drawable);
+        updateViews();
+    }
+
+    /** Updates progress if the notification matches the tracked key */
+    private void updateProgressIfNeeded(final StatusBarNotification sbn) {
+        if (!mIsTrackingProgress) {
+            Log.wtf(TAG, "Called updateProgress if needed, but we are not tracking anything");
+            return;
+        }
+        if (sbn.getKey().equals(mTrackedNotificationKey)) {
+            extractProgress(sbn.getNotification());
+            updateViews();
+        }
+    }
+
+    /** Finds a notification by its key */
+    private StatusBarNotification findNotificationByKey(String key) {
+        for (StatusBarNotification notification : mNotificationListener.getActiveNotifications()) {
+            if (notification.getKey().equals(key)) {
+                return notification;
+            }
+        }
+        return null;
+    }
+
+    /** Checks if a notification has progress */
+    private static boolean hasProgress(final Notification notification) {
+        Bundle extras = notification.extras;
+        boolean indeterminate = extras.getBoolean(Notification.EXTRA_PROGRESS_INDETERMINATE, false);
+        boolean maxProgressValid = extras.getInt(Notification.EXTRA_PROGRESS_MAX, 0) > 0;
+        return extras.containsKey(Notification.EXTRA_PROGRESS) &&
+                extras.containsKey(Notification.EXTRA_PROGRESS_MAX) &&
+                !indeterminate && maxProgressValid;
+    }
+
+    /** Updates the icon view based on drawable properties */
+    private void updateIconImageView(IconFetcher.AdaptiveDrawableResult drawable) {
+        mIconView.setImageTintList(drawable.isAdaptive ?
+                ColorStateList.valueOf(getThemeColor(mContext, android.R.attr.colorForeground)) : null);
+        mIconView.setImageDrawable(drawable.drawable);
+    }
+
+    /** Shows a media control popup */
     private void showMediaPopup(View anchorView) {
         if (mMediaPopup != null && mMediaPopup.isShowing()) {
             mMediaPopup.dismiss();
             return;
         }
 
-        // Inflate the popup layout
         View popupView = LayoutInflater.from(mContext).inflate(R.layout.media_control_popup, null);
-
-        // Initialize PopupWindow
         mMediaPopup = new PopupWindow(popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true);
         mMediaPopup.setOutsideTouchable(true);
         mMediaPopup.setFocusable(true);
 
-        // Set up buttons (Only Previous & Next)
         ImageButton btnPrevious = popupView.findViewById(R.id.btn_previous);
         ImageButton btnNext = popupView.findViewById(R.id.btn_next);
-
-        // Set button actions
         btnPrevious.setOnClickListener(v -> {
             skipToPreviousTrack();
             mMediaPopup.dismiss();
         });
-
         btnNext.setOnClickListener(v -> {
             skipToNextTrack();
             mMediaPopup.dismiss();
         });
 
-        // Show popup near the anchor view
         anchorView.post(() -> {
             int offsetX = -popupView.getWidth() / 3;
             int offsetY = -anchorView.getHeight();
@@ -410,21 +338,14 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         });
     }
 
-    /** Handles click action to open the corresponding app */
+    /** Opens the app associated with the tracked notification */
     private void openTrackedApp() {
         if (mTrackedNotificationKey == null || mNotificationListener == null) {
             Log.w(TAG, "No tracked notification available");
             return;
         }
 
-        StatusBarNotification sbn = null;
-        for (StatusBarNotification notification : mNotificationListener.getActiveNotifications()) {
-            if (notification.getKey().equals(mTrackedNotificationKey)) {
-                sbn = notification;
-                break;
-            }
-        }
-
+        StatusBarNotification sbn = findNotificationByKey(mTrackedNotificationKey);
         if (sbn == null) {
             Log.w(TAG, "Tracked notification not found");
             return;
@@ -440,17 +361,11 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         }
     }
 
-    /**
-     * Should be called when new notification is posted
-     *
-     * @param StatusBarNotification a notification which was posted
-     */
+    /** Handles notification posted event */
     private void onNotificationPosted(final StatusBarNotification sbn) {
         Notification notification = sbn.getNotification();
         if (!hasProgress(notification)) {
-            // Log.d(TAG, "Got notification without progress");
             if (mTrackedNotificationKey != null && mTrackedNotificationKey.equals(sbn.getKey())) {
-                // The notification we track has no progress anymore
                 Log.d(TAG, "Tracked notification has lost progress");
                 synchronized (this) {
                     mIsTrackingProgress = false;
@@ -469,98 +384,85 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         }
     }
 
-    /**
-     * Should be call when notification is removed
-     *
-     * @param StatusBarNotification a notification which was removed
-     */
+    /** Handles notification removed event */
     private void onNotificationRemoved(final StatusBarNotification sbn) {
         synchronized (this) {
-            if (!mIsTrackingProgress) {
+            if (!mIsTrackingProgress || !sbn.getKey().equals(mTrackedNotificationKey)) {
                 return;
             }
-            if (sbn.getKey().equals(mTrackedNotificationKey)) {
-                mIsTrackingProgress = false;
-                mCurrentDrawable = null;
-                updateViews();
-            }
+            mIsTrackingProgress = false;
+            mCurrentDrawable = null;
+            updateViews();
         }
     }
 
-    /**
-     * Sets hide chip override
-     * @param forceHidden if setted to true the chip would not be visible under any cricumctances
-     */
-    public void setForceHidden(final boolean forceHidden){
-            Log.d(TAG, "setForceHidden " + forceHidden);
+    /** Sets force hidden state */
+    public void setForceHidden(final boolean forceHidden) {
+        Log.d(TAG, "setForceHidden " + forceHidden);
         mIsForceHidden = forceHidden;
         updateViews();
     }
 
-    // Gesture Actions for Media Progress Bar
-    private void toggleMediaPlaybackState() {
-        mMediaSessionHelper.toggleMediaPlaybackState();
-    }
-
-    private void skipToNextTrack() {
-        mMediaSessionHelper.nextSong();
-    }
-
-    private void skipToPreviousTrack() {
-        mMediaSessionHelper.prevSong();
-    }
-
-    private void openMediaApp() {
-        mMediaSessionHelper.launchMediaApp();
-    }
+    private void toggleMediaPlaybackState() { mMediaSessionHelper.toggleMediaPlaybackState(); }
+    private void skipToNextTrack() { mMediaSessionHelper.nextSong(); }
+    private void skipToPreviousTrack() { mMediaSessionHelper.prevSong(); }
+    private void openMediaApp() { mMediaSessionHelper.launchMediaApp(); }
 
-    // Implementation of notification handler
     @Override
-    public void onNotificationPosted(
-            StatusBarNotification sbn, NotificationListenerService.RankingMap _rankingMap) {
+    public void onNotificationPosted(StatusBarNotification sbn, NotificationListenerService.RankingMap _rankingMap) {
         onNotificationPosted(sbn);
     }
 
     @Override
-    public void onNotificationRemoved(
-            StatusBarNotification sbn, NotificationListenerService.RankingMap rankingMap) {
+    public void onNotificationRemoved(StatusBarNotification sbn, NotificationListenerService.RankingMap _rankingMap) {
         onNotificationRemoved(sbn);
     }
 
     @Override
-    public void onNotificationRemoved(
-            StatusBarNotification sbn,
-            NotificationListenerService.RankingMap _rankingMap,
-            int _reason) {
+    public void onNotificationRemoved(StatusBarNotification sbn, NotificationListenerService.RankingMap _rankingMap, int _reason) {
         onNotificationRemoved(sbn);
     }
 
     @Override
-    public void onNotificationRankingUpdate(NotificationListenerService.RankingMap _rankingMap) {
-        /*stub*/
-    }
-
+    public void onNotificationRankingUpdate(NotificationListenerService.RankingMap _rankingMap) { /* stub */ }
     @Override
-    public void onNotificationsInitialized() {
-        /*stub*/
-    }
+    public void onNotificationsInitialized() { /* stub */ }
 
-    // Callback from keyguard state
     @Override
-    public void onKeyguardShowingChanged(){
+    public void onKeyguardShowingChanged() {
         setForceHidden(mKeyguardStateController.isShowing());
     }
 
-    private void updateSettings() {
-        mIsEnabled = Settings.System.getIntForUser(mContentResolver,
-        ONGOING_ACTION_CHIP_ENABLED, 1, UserHandle.USER_CURRENT) == 1;
+    /** Settings observer for system settings */
+    private class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) { super(handler); }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            super.onChange(selfChange, uri);
+            if (uri.equals(Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED)) ||
+                    uri.equals(Settings.System.getUriFor(SHOW_MEDIA_PROGRESS))) {
+                updateSettings();
+            }
+        }
 
-        mShowMediaProgress = Settings.System.getIntForUser(mContentResolver,
-            SHOW_MEDIA_PROGRESS, 1, UserHandle.USER_CURRENT) == 1;
+        public void register() {
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED), false, this, UserHandle.USER_ALL);
+            mContentResolver.registerContentObserver(Settings.System.getUriFor(SHOW_MEDIA_PROGRESS), false, this, UserHandle.USER_ALL);
+            updateSettings();
+        }
 
+        public void unregister() { mContentResolver.unregisterContentObserver(this); }
+    }
+
+    /** Updates settings from system preferences */
+    private void updateSettings() {
+        mIsEnabled = Settings.System.getIntForUser(mContentResolver, ONGOING_ACTION_CHIP_ENABLED, 1, UserHandle.USER_CURRENT) == 1;
+        mShowMediaProgress = Settings.System.getIntForUser(mContentResolver, SHOW_MEDIA_PROGRESS, 1, UserHandle.USER_CURRENT) == 1;
         updateViews();
     }
 
+    /** Cleans up resources */
     public void destroy() {
         mSettingsObserver.unregister();
         mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
@@ -571,4 +473,10 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         mTrackedNotificationKey = null;
         mIconView.setImageDrawable(null);
     }
+
+    private static int getThemeColor(Context context, int attrResId) {
+        TypedValue typedValue = new TypedValue();
+        context.getTheme().resolveAttribute(attrResId, typedValue, true);
+        return typedValue.data;
+    }
 }
-- 
2.43.0

