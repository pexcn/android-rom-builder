From fbbd24c185f8c1543df9bbf3e9241eb2eacf6475 Mon Sep 17 00:00:00 2001
From: Ghosuto <clash.raja10@gmail.com>
Date: Fri, 21 Mar 2025 16:25:28 +0000
Subject: [PATCH] SystemUI: Introduce media playback progress bar in action
 chip

- Add support for displaying media playback progress in the status bar.
- Integrate MediaSessionManagerHelper (thanks to RisingOS and AxionAOSP) to track media playback state.
- Show media progress only when music/video is playing; hide during downloads.
- Add gesture controls:
  - Single tap: stop media.
  - Double tap: Skip to the next track.
  - Long press: Open the media app.

Signed-off-by: Ghosuto <clash.raja10@gmail.com>
---
 core/java/android/provider/Settings.java      |   5 +
 .../res/drawable/ic_default_music_icon.xml    |  11 +
 .../OnGoingActionProgressController.java      | 147 +++++++++-
 .../util/MediaSessionManagerHelper.kt         | 263 ++++++++++++++++++
 4 files changed, 418 insertions(+), 8 deletions(-)
 create mode 100644 packages/SystemUI/res/drawable/ic_default_music_icon.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/util/MediaSessionManagerHelper.kt

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index b72f27359..a57c12971 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -6893,6 +6893,11 @@ public final class Settings {
             PRIVATE_SETTINGS.add(AUTO_BRIGHTNESS_ONE_SHOT);
         }
 
+        /**
+         * @hide
+         */
+        public static final String SHOW_MEDIA_PROGRESS = "show_media_progress";
+
         /**
          * @hide
          */
diff --git a/packages/SystemUI/res/drawable/ic_default_music_icon.xml b/packages/SystemUI/res/drawable/ic_default_music_icon.xml
new file mode 100644
index 000000000..3bbd10e71
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_default_music_icon.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+    <path
+        android:fillColor="?android:attr/colorForeground"
+        android:pathData="M12,3V21L19,16V8L12,3Z M7,8V16L12,21V3L7,8Z" />
+</vector>
+
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java b/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
index 5029b0868..099658f8f 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/OnGoingActionProgressController.java
@@ -33,6 +33,8 @@ import android.service.notification.NotificationListenerService;
 import android.service.notification.StatusBarNotification;
 import android.util.Log;
 import android.util.TypedValue;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
@@ -41,11 +43,13 @@ import com.android.systemui.res.R;
 import com.android.systemui.util.IconFetcher;
 import com.android.systemui.statusbar.OnGoingActionProgressGroup;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
+import com.android.systemui.statusbar.util.MediaSessionManagerHelper;
 
 /** Controls the ongoing progress chip based on notifcations @LineageExtension */
 public class OnGoingActionProgressController implements NotificationListener.NotificationHandler, KeyguardStateController.Callback {
     private static final String TAG = "OngoingActionProgressController";
     private static final String ONGOING_ACTION_CHIP_ENABLED = "ongoing_action_chip";
+    private static final String SHOW_MEDIA_PROGRESS = "show_media_progress";
 
     private Context mContext;
     private ContentResolver mContentResolver;
@@ -61,6 +65,7 @@ public class OnGoingActionProgressController implements NotificationListener.Not
     private final KeyguardStateController mKeyguardStateController;
 
     // Progress tracking variables
+    private boolean mShowMediaProgress = true;
     private boolean mIsTrackingProgress = false;
     private boolean mIsForceHidden = false;
     private int mCurrentProgress = 0;
@@ -72,6 +77,21 @@ public class OnGoingActionProgressController implements NotificationListener.Not
     private final NotificationListener mNotificationListener;
     private boolean mIsEnabled;
 
+    private final GestureDetector mGestureDetector;
+    private final MediaSessionManagerHelper mMediaSessionHelper;
+
+    // Handler for real-time media progress updates
+    private final Handler mMediaProgressHandler = new Handler(Looper.getMainLooper());
+    private final Runnable mMediaProgressRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (mShowMediaProgress && mMediaSessionHelper.isMediaPlaying()) {
+                updateViews();
+                mMediaProgressHandler.postDelayed(this, 1000); // Update every second
+            }
+        }
+    };
+
     private static int getThemeColor(Context context, int attrResId) {
         TypedValue typedValue = new TypedValue();
         context.getTheme().resolveAttribute(attrResId, typedValue, true);
@@ -86,7 +106,8 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         @Override
         public void onChange(boolean selfChange, Uri uri) {
             super.onChange(selfChange, uri);
-            if (uri.equals(Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED))) {
+            if (uri.equals(Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED)) ||
+                uri.equals(Settings.System.getUriFor(SHOW_MEDIA_PROGRESS))) {
                 updateSettings();
             }
         }
@@ -95,7 +116,12 @@ public class OnGoingActionProgressController implements NotificationListener.Not
             mContentResolver.registerContentObserver(
                 Settings.System.getUriFor(ONGOING_ACTION_CHIP_ENABLED),
                 false, this, UserHandle.USER_ALL);
-            // Update initial state
+            
+            // Register observer for media progress toggle
+            mContentResolver.registerContentObserver(
+                Settings.System.getUriFor(SHOW_MEDIA_PROGRESS),
+                false, this, UserHandle.USER_ALL);
+            
             updateSettings();
         }
 
@@ -132,11 +158,44 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         mIconView = progressGroup.iconView;
         mIconFetcher = new IconFetcher(context);
         mNotificationListener.addNotificationHandler(this);
+        mMediaSessionHelper = MediaSessionManagerHelper.Companion.getInstance(context);
         
+        // ðŸ”¹ Initialize gesture detector for media progress bar actions
+        mGestureDetector = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {
+            @Override
+            public boolean onSingleTapConfirmed(MotionEvent e) {
+                toggleMediaPlaybackState();
+                return true;
+            }
+
+            @Override
+            public boolean onDoubleTap(MotionEvent e) {
+                skipToNextTrack();
+                return true;
+            }
+
+            @Override
+            public void onLongPress(MotionEvent e) {
+                openMediaApp();
+            }
+        });
+
         // Register settings observer
         mSettingsObserver.register();
-        mProgressRootView.setOnClickListener(v -> openTrackedApp());
-    }
+        mProgressRootView.setOnTouchListener((v, event) -> mGestureDetector.onTouchEvent(event));
+        // Add Media Listener to Update UI on Media Playback Change
+            mMediaSessionHelper.addMediaMetadataListener(new MediaSessionManagerHelper.MediaMetadataListener() {
+                @Override
+                public void onMediaMetadataChanged() {
+                    updateViews();
+                }
+
+                @Override
+                public void onPlaybackStateChanged() {
+                    updateViews();
+                }
+            });
+        }
 
     /** Checks whether notification has progress */
     private static boolean hasProgress(final Notification notification) {
@@ -198,24 +257,74 @@ public class OnGoingActionProgressController implements NotificationListener.Not
 
     /** Updates progress views @AsyncUnsafe */
     private void updateViews() {
-        if(mIsForceHidden){ // Keyguard locked, user-disabled, etc.
+        if (mIsForceHidden) {
             mProgressRootView.setVisibility(View.GONE);
             return;
         }
+
+        boolean isMediaPlaying = mShowMediaProgress && mMediaSessionHelper.isMediaPlaying();
+
+        // If media is playing and it's enabled, show media progress
+        if (isMediaPlaying) {
+            mProgressRootView.setVisibility(View.VISIBLE);
+
+            mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
+            mMediaProgressHandler.post(mMediaProgressRunnable);
+
+            // Get media app icon and update it
+            Drawable mediaAppIcon = mMediaSessionHelper.getMediaAppIcon();
+            if (mediaAppIcon != null) {
+                mIconView.setImageDrawable(mediaAppIcon);
+            } else {
+                mIconView.setImageResource(R.drawable.ic_default_music_icon);
+            }
+
+            long totalDuration = mMediaSessionHelper.getTotalDuration();
+            long currentProgress = mMediaSessionHelper.getMediaControllerPlaybackState() != null
+                    ? mMediaSessionHelper.getMediaControllerPlaybackState().getPosition()
+                    : 0;
+
+            if (totalDuration > 0) {
+                mProgressBar.setMax((int) totalDuration);
+                mProgressBar.setProgress((int) currentProgress);
+            }
+            return;
+        }
+
+        // If no media is playing, show download/upload progress as usual
         if (!mIsEnabled || !mIsTrackingProgress) {
             mProgressRootView.setVisibility(View.GONE);
+            mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
             return;
         }
-        // TODO: make it a bit faster by checking wether mIsTrackingProgress has changed between
-        // calls
+
         mProgressRootView.setVisibility(View.VISIBLE);
+
         if (mCurrentProgressMax <= 0) {
             Log.w(TAG, "updateViews: invalid max progress " + mCurrentProgressMax + ", using 100");
             mCurrentProgressMax = 100;
         }
+
         Log.d(TAG, "updateViews: " + mCurrentProgress + "/" + mCurrentProgressMax);
         mProgressBar.setMax(mCurrentProgressMax);
         mProgressBar.setProgress(mCurrentProgress);
+
+        // When switching to download progress, update the correct download app icon
+        if (mTrackedNotificationKey != null) {
+            StatusBarNotification sbn = null;
+            for (StatusBarNotification notification : mNotificationListener.getActiveNotifications()) {
+                if (notification.getKey().equals(mTrackedNotificationKey)) {
+                    sbn = notification;
+                    break;
+                }
+            }
+            if (sbn != null) {
+                Drawable downloadAppIcon = mIconFetcher.getMonotonicPackageIcon(sbn.getPackageName()).drawable;
+                if (downloadAppIcon != null) {
+                    mIconView.setImageDrawable(downloadAppIcon);
+                }
+            }
+        }
     }
 
     /** Handles click action to open the corresponding app */
@@ -305,6 +414,23 @@ public class OnGoingActionProgressController implements NotificationListener.Not
         updateViews();
     }
 
+    // Gesture Actions for Media Progress Bar
+    private void toggleMediaPlaybackState() {
+        if (mMediaSessionHelper.isMediaPlaying()) {
+            mMediaSessionHelper.toggleMediaPlaybackState();
+        } else {
+            mMediaSessionHelper.toggleMediaPlaybackState();
+        }
+    }
+
+    private void skipToNextTrack() {
+        mMediaSessionHelper.nextSong();
+    }
+
+    private void openMediaApp() {
+        mMediaSessionHelper.launchMediaApp();
+    }
+
     // Implementation of notification handler
     @Override
     public void onNotificationPosted(
@@ -344,12 +470,17 @@ public class OnGoingActionProgressController implements NotificationListener.Not
 
     private void updateSettings() {
         mIsEnabled = Settings.System.getIntForUser(mContentResolver,
-            ONGOING_ACTION_CHIP_ENABLED, 1, UserHandle.USER_CURRENT) == 1;
+        ONGOING_ACTION_CHIP_ENABLED, 1, UserHandle.USER_CURRENT) == 1;
+
+        mShowMediaProgress = Settings.System.getIntForUser(mContentResolver,
+            SHOW_MEDIA_PROGRESS, 1, UserHandle.USER_CURRENT) == 1;
+
         updateViews();
     }
 
     public void destroy() {
         mSettingsObserver.unregister();
+        mMediaProgressHandler.removeCallbacks(mMediaProgressRunnable);
         mIsTrackingProgress = false;
         mCurrentDrawable = null;
         mCurrentProgress = 0;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/util/MediaSessionManagerHelper.kt b/packages/SystemUI/src/com/android/systemui/statusbar/util/MediaSessionManagerHelper.kt
new file mode 100644
index 000000000..bb0c4c2e2
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/util/MediaSessionManagerHelper.kt
@@ -0,0 +1,263 @@
+/*
+* Copyright (C) 2023-2024 The risingOS Android Project
+* Copyright (C) 2025 The AxionAOSP Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.android.systemui.statusbar.util
+
+import android.content.Context
+import android.content.res.Configuration
+import android.content.pm.PackageManager
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.media.MediaMetadata
+import android.media.session.MediaController
+import android.media.session.MediaSessionLegacyHelper
+import android.media.session.MediaSessionManager
+import android.media.session.PlaybackState
+import android.os.SystemClock
+import android.provider.Settings
+import android.text.TextUtils
+import android.view.KeyEvent
+import android.view.View
+
+import kotlinx.coroutines.*
+import kotlinx.coroutines.flow.*
+
+class MediaSessionManagerHelper private constructor(private val context: Context) {
+
+    interface MediaMetadataListener {
+        fun onMediaMetadataChanged() {}
+        fun onPlaybackStateChanged() {}
+    }
+
+    private val _mediaMetadata = MutableStateFlow<MediaMetadata?>(null)
+    val mediaMetadata: StateFlow<MediaMetadata?> = _mediaMetadata
+
+    private val _playbackState = MutableStateFlow<PlaybackState?>(null)
+    val playbackState: StateFlow<PlaybackState?> = _playbackState
+
+    private val scope = CoroutineScope(Dispatchers.Main)
+    private var collectJob: Job? = null
+
+    private var lastSavedPackageName: String? = null
+    private val mediaSessionManager: MediaSessionManager = context.getSystemService(MediaSessionManager::class.java)!!
+    private var activeController: MediaController? = null
+    private val listeners = mutableSetOf<MediaMetadataListener>()
+
+    private val mediaControllerCallback = object : MediaController.Callback() {
+        override fun onMetadataChanged(metadata: MediaMetadata?) {
+            _mediaMetadata.value = metadata
+        }
+
+        override fun onPlaybackStateChanged(state: PlaybackState?) {
+            _playbackState.value = state
+        }
+    }
+
+    private val tickerFlow = flow {
+        while (true) {
+            emit(Unit)
+            delay(1000)
+        }
+    }.flowOn(Dispatchers.Default)
+
+    init {
+        lastSavedPackageName = Settings.System.getString(
+            context.contentResolver,
+            "media_session_last_package_name"
+        )
+
+        scope.launch {
+            tickerFlow
+                .map { fetchActiveController() }
+                .distinctUntilChanged { old, new -> sameSessions(old, new) }
+                .collect { controller ->
+                    activeController?.unregisterCallback(mediaControllerCallback)
+                    activeController = controller
+                    controller?.registerCallback(mediaControllerCallback)
+                    _mediaMetadata.value = controller?.metadata
+                    _playbackState.value = controller?.playbackState
+                    saveLastNonNullPackageName()
+                }
+        }
+    }
+
+    private suspend fun fetchActiveController(): MediaController? = withContext(Dispatchers.IO) {
+        var localController: MediaController? = null
+        val remoteSessions = mutableSetOf<String>()
+        
+        mediaSessionManager.getActiveSessions(null)
+            .filter { controller ->
+                controller.playbackState?.state == PlaybackState.STATE_PLAYING &&
+                controller.playbackInfo != null
+            }
+            .forEach { controller ->
+                when (controller.playbackInfo?.playbackType) {
+                    MediaController.PlaybackInfo.PLAYBACK_TYPE_REMOTE -> {
+                        remoteSessions.add(controller.packageName)
+                        if (localController?.packageName == controller.packageName) {
+                            localController = null
+                        }
+                    }
+                    MediaController.PlaybackInfo.PLAYBACK_TYPE_LOCAL -> {
+                        if (!remoteSessions.contains(controller.packageName)) {
+                            localController = localController ?: controller
+                        }
+                    }
+                }
+            }
+        localController
+    }
+
+    fun addMediaMetadataListener(listener: MediaMetadataListener) {
+        listeners.add(listener)
+        if (listeners.size == 1) {
+            startCollecting()
+        }
+        listener.onMediaMetadataChanged()
+        listener.onPlaybackStateChanged()
+    }
+
+    fun removeMediaMetadataListener(listener: MediaMetadataListener) {
+        listeners.remove(listener)
+        if (listeners.isEmpty()) {
+            stopCollecting()
+        }
+    }
+
+    private fun startCollecting() {
+        collectJob = scope.launch {
+            launch { mediaMetadata.collect { notifyListeners { onMediaMetadataChanged() } } }
+            launch { playbackState.collect { notifyListeners { onPlaybackStateChanged() } } }
+        }
+    }
+
+    private fun stopCollecting() {
+        collectJob?.cancel()
+        collectJob = null
+    }
+
+    private fun notifyListeners(action: MediaMetadataListener.() -> Unit) {
+        listeners.forEach { it.action() }
+    }
+
+    fun seekTo(time: Long) {
+        activeController?.transportControls?.seekTo(time)
+    }
+
+    fun getTotalDuration() = mediaMetadata.value?.getLong(MediaMetadata.METADATA_KEY_DURATION) ?: 0L
+
+    private fun saveLastNonNullPackageName() {
+        activeController?.packageName?.takeIf { it.isNotEmpty() }?.let { pkg ->
+            if (pkg != lastSavedPackageName) {
+                Settings.System.putString(
+                    context.contentResolver,
+                    "media_session_last_package_name",
+                    pkg
+                )
+                lastSavedPackageName = pkg
+            }
+        }
+    }
+
+    fun getMediaBitmap(): Bitmap? = mediaMetadata.value?.let {
+        it.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART) ?: 
+        it.getBitmap(MediaMetadata.METADATA_KEY_ART) ?: 
+        it.getBitmap(MediaMetadata.METADATA_KEY_DISPLAY_ICON)
+    }
+    
+    fun getCurrentMediaMetadata(): MediaMetadata? {
+        return mediaMetadata.value
+    }
+
+    fun getMediaAppIcon(): Drawable? {
+        val packageName = activeController?.packageName ?: return null
+        return try {
+            val pm = context.packageManager
+            pm.getApplicationIcon(packageName)
+        } catch (e: PackageManager.NameNotFoundException) {
+            null
+        }
+    }
+
+    fun isMediaControllerAvailable() = activeController?.packageName?.isNotEmpty() ?: false
+
+    fun isMediaPlaying() = playbackState.value?.state == PlaybackState.STATE_PLAYING
+
+    fun getMediaControllerPlaybackState(): PlaybackState? {
+        return activeController?.playbackState ?: null
+    }
+
+    private fun sameSessions(a: MediaController?, b: MediaController?): Boolean {
+        if (a == b) return true
+        if (a == null) return false
+        return a.controlsSameSession(b)
+    }
+
+    private fun dispatchMediaKeyWithWakeLockToMediaSession(keycode: Int) {
+        val helper = MediaSessionLegacyHelper.getHelper(context) ?: return
+        var event = KeyEvent(
+            SystemClock.uptimeMillis(),
+            SystemClock.uptimeMillis(),
+            KeyEvent.ACTION_DOWN,
+            keycode,
+            0
+        )
+        helper.sendMediaButtonEvent(event, true)
+        event = KeyEvent.changeAction(event, KeyEvent.ACTION_UP)
+        helper.sendMediaButtonEvent(event, true)
+    }
+
+    fun prevSong() {
+        dispatchMediaKeyWithWakeLockToMediaSession(KeyEvent.KEYCODE_MEDIA_PREVIOUS)
+    }
+
+    fun nextSong() {
+        dispatchMediaKeyWithWakeLockToMediaSession(KeyEvent.KEYCODE_MEDIA_NEXT)
+    }
+
+    fun toggleMediaPlaybackState() {
+        if (isMediaPlaying()) {
+            dispatchMediaKeyWithWakeLockToMediaSession(KeyEvent.KEYCODE_MEDIA_PAUSE)
+        } else {
+            dispatchMediaKeyWithWakeLockToMediaSession(KeyEvent.KEYCODE_MEDIA_PLAY)
+        }
+    }
+
+    fun launchMediaApp() {
+        lastSavedPackageName?.takeIf { it.isNotEmpty() }?.let {
+            launchMediaPlayerApp(it)
+        }
+    }
+    
+    fun launchMediaPlayerApp(packageName: String) {
+        if (packageName.isNotEmpty()) {
+            val launchIntent = context.packageManager.getLaunchIntentForPackage(packageName)
+            launchIntent?.let { intent ->
+                context.startActivity(intent)
+            }
+        }
+    }
+
+    companion object {
+        @Volatile
+        private var instance: MediaSessionManagerHelper? = null
+
+        fun getInstance(context: Context): MediaSessionManagerHelper =
+            instance ?: synchronized(this) {
+                instance ?: MediaSessionManagerHelper(context).also { instance = it }
+            }
+    }
+}
\ No newline at end of file
-- 
2.43.0

